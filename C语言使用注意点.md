# C语言使用注意点

标签: 编程注意点 C语言

---
##指针
(1)有效性的校验很重要，原则上只要用到指针就必须要校验其有效性。常见的易出错误的有文件读写函数，内存管理函数（其中特别要注意realloc()函数，其返回的也是一个指针，它不是把原来指针指向空间增大，而是把原来的内容复制到一个更大的空间中去，返回另外一个指针）。

(2)指针作为函数形参，以及二级指针的选用
如果要改变指针指向的值，则用指针；如果要改变指针的值，则用二级指针（这个一定要注意！）。易出现的问题是对指针的逻辑结构不清楚，导致在该用二级指针的地方用了一级指针，结果使实参（指针）没有被改变。所谓用指针传地址，其实对于作为形参的指针来说是传值的（指针作为形参是被拷贝过去的），不过对于指针指向的元素来说是传址的。

(3)C++中引用与C指针的区别
C++中引用是编译器通过指针实现的，但比指针使用更简洁，引用不是类型，没有空引用或者引用的引用。将其改写为相应的指针实现是要注意有无const修饰！
``` C
int func(const int &a);    //C++   此处用引用降低了调用函数传参的成本
int func(int a);           //C
int func(const int *&a);   //C++   这样写不可以改变指针的值
int func(int *a);          //C
int func(int *&a);         //C++   这样写可以改变指针的值
int func(int **a);         //C
```
(4)指针值的加减
Type* p=&a;
p=p+b;(等价于p=&a+b*sizeof(Type);)
p[a]实际上就是*(p+a)
tips：使用指针运算，有很大的好处。例如，如果想要以字节为单位研究某个大型类型的存储方式，可以使用一个char *p，然后由于*p访问的实际上是一个字节，所以通过对指针p的运算，可以读取出任意位置的一个字节。

(5)函数指针的运用
C语言是不支持模板的概念的，为实现函数的多态性，可以使用重载或函数指针。 函数指针举例
``` C
int (*comp) ( int * a,int * b);            //函数指针
int  *comp(int *a,int *b);                 //返回int*的函数
Qsort(char* v[] , 1, 10 ,(int (*) (void*,void*) ) (judge ? func_1 : func-2 ))；
//巧妙利用“? :”运算符，(int (*) (void *, void*))即为函数指针的类型，调用时不一定要写！
```
注意void*的巧妙使用，可以统一解决很多类型不同的问题；调用函数指针作为参数时，直接写函数名。 还是来个实际的例子吧
```C
#include<stdio.h>
#include<string.h>

void func_1(int *a,int *b)
{
	printf(”%d   %d”,*a,*b);
}

void func_2(char *a,char *b)
{
	printf(”%s  %s”,a,b);
}
//函数指针其实和被调用的函数没有任何关系，被调用的函数该怎么写就怎么写，不要写成void (*func_1)(int *a,int *b);这是声明！

void call(void *s1,void *s2,void(*func)(void*,void* ))            //声明时可以不写形参
{
	(*func)(s1,s2);
}

int main()
{
	int judge;
	char string_1[]=”hello world”;
	char string_2[]=”hi”;
	scanf(”%d”,&judge);
	if(judge==1)
	call(string_1,string_2,func_1);
	else
	call(string_1,string_2,func_2);
}
```
//编译器对于类型转换一般都会有warning，所以在使用void*时要万分小心！
(6)字符指针与函数
字符串常量是一个字符数组，存储在全局数据取，其空间并不是动态随运行分配的，显然动态分配似乎也不太可行，一般来说是在全局数据区。常量指针实际是无名的，但可以将其使用printf()打印，就像这样printf("%s\n","hello world!");。
char *p=s;   /* s is an array of char */
p="China";   /* 字符串常量一般类型是char* */
s="China";   /* s的地址似乎不可以改变，即s是个右值？？？
给自己的一个数组赋值除了一个一个读取还有什么解决方案？？？
这两次操作是p的地址大不相同，第一次p一般是栈上自动分配的，而第二次的赋值实际上将p的数值更改为字符数组的地址，而且一般来说，第一次的地址比第二次的地址要大很多，因为一个在全局数据区，另一个在栈上。

##数组
(1)一维数组与二维数组映射的问题
一般来说，能用二维数组的地方尽量使用二维数组，不要使用一维数组，再将二维数组映射到一维上，不仅麻烦，还容易出错。
可以使用一个宏定义或者小函数完成映射，降低出错的概率。
使用动态内存分配时问题集中在malloc只能分配连续的空间，我们一般用来作一维数组使用，而不好像C++的new操作符一样分分钟申请一个多维数组。
但有以下处理方式，可以使我们把它当做二维数组来访问。
int (*p)[b]=(int (*)[b])malloc(sizeof(Type)*a*b);
p[1][2]=0;

(2)数组初始化的一种简单办法int array[100][100]={0};
利用编译器的自动补全即可。

(3)数组、指针访问越界
静态数组或动态内存分配的空间无论是用下标或指针访问都有可能越界，而且越界后还可以读写（虽然是非法的），编译或运行时没有任何提醒。对于指针，唯一的常见的提醒是访问NULL指针时系统会终止程序运行，程序崩溃。（C语言保证，0永远不是有效的数据地址）
C语言是十分危险的一门编程语言。

(4)数组作为函数参数
int a[10];
参数                    类型          
a			int *
&a			int (*)[10]

int a[10][10];
参数			类型
a			    int (*)[10]
&a			    int (*)[10][10]
&a[0][0]		int *
&a[0]			int (*)[10]

(5)函数参数中的结构体如果包含大数组时，具体的传参方式尚不清楚，但如果数组很大，就会出现问题，提示似乎是对齐错误？？？？？？

由此可见：
Type(&a)=(*Type(a))                                        //这个是始终成立的
若a为数组，且有Type a[a_1][a_2][a_3]...........[a_n]
Type(a)=Type(*)[a_2][a_3][a_4].........[a_n]               //仅在作为函数实参或形参时成立，少掉了第一维

(6)
字符串结尾判断时，使用'\n'，千万不要打成"\n"，前者是int型的，后者则是一个常量字符串（指针）！


##整数的使用
(1)
int a=-1;
-1/3=0;
出现不同数据结构中存储位置的映射时，可以考虑利用整数运算的某些特性。
(2)向上向下取整
对于正小数，向下取整；对于负小数，向上取整。

(2)C语言的整数取模运算
``` c
(-1)%3=-1;
(-2)%3=-2;
(-3)%3=-3;
(-4)%3=-1;
(-5)%3=-2;
(-6)%3=0；
```
(3)各整数类型的表示范围及整数溢出
在<limits.h>中有各种类型整数的上下界，在编程中可以选取上下界表示无穷大。


4、随机数
(1)生成随机数注意种子的选择，慎用系统时间作为种子
```c
int Random()
{
	srand(time(NULL));
	return rand();
}
```
在使用上述常用组合时有一个隐藏的bug，即如果用连续生成随机数，相邻的随机数会相同，这是因为srand函数以当前系统时间为种子，而CPU指令执行的周期远小于系统时间计量的最小单位，这就导致在一个系统时间计量的最小单位内，CPU生成了许多完全相同的随机数，这就严重降低了生成随机数的效率。这种bug有一个特点就是执行时很明显的生成了相同的随机数，而在单步调试时根本不会出现相同的随机数。以后遇到单步调试和实际运行时运行现象大不相同的情况下，多用控制变量法的思想分析比较，找出产生bug的原因。例如此处的变量就是系统时间。

(2)生成随机数填充数据结构（例如：随机生成1、2、3、4、5、6、7、8、9这九个数的一个排列）时怎样提高效率？
关键在于减少冲撞，可采用重映射的方式，减小随机数的生成空间例如第一个随机出的数是5，为避免以后随机出的数是5，可以作如下映射 1、2、3、4、6、7、8、9->1、2、3、4、5、6、7、8生成一个1~8之间的数，在将其映射为原先的数 映射的成本是固定的，即有时间上限；而随机解决有可能没有上限。


##C语言的枚举类型
enum color{red,black=10,pink};
注意枚举类型的默认赋值方式，在这里red=0,black=10,pink=11。

##怎样用C编写简单的界面？
下面给出一个示例（来自陈挚和袁帅的sudoku程序） 
	printf("╔══════════════════════════════════════╗");
	printf(”║              Hello！我是会卖萌的iSudoku 6 plus ~~ o(^▽^)o                 ║”);
	printf("╠══════════════════════════════════════╣");
	printf(”║    啦啦啦，有什么需要我帮助的咩？(≧▽≦)                                  ║”);
	printf(”║    1-快来帮我解一道数独题！    2-快出一道数独题给我！    else-再见！       ║”);
   	printf("╚══════════════════════════════════════╝");
	printf(”  ________.\b\b\b\b\b\b\b\b”);
利用输入输出函数就可以搭建简单的框架了，注意里面有一个printf(” ________.\b\b\b\b\b\b\b\b”);用的极好，printf(“\b”);实现的是退一格，即可以将光标后移若干格。


##命令行变元与<stdarg.h>main函数的标准格式是这样的
int main(int argc,char* argv[]);
关于命令行参数的传入
首先看一下这个：
http://baike.baidu.com/link?url=2vgaRfMGB-ruyBe_iKsHbFFA6JQ1qeb0S4HFLvrEk6XlEb56ZRmY0SLQkGwcPbVtJb0eIVqAXNWV_hbr3pP5Qa
其次有几个注意点，默认无参数时，系统调用时argc赋值0，argv[0]是？首先argv[0]由操作系统填，我们输入的命令行变元从argv[1]开始填
有几个问题：
（1）可以访问argv[0]吗？为何在printf()时会出现段错误，而strcmp()就不出现段错误？查一下那个ANSI C标准！
（2）如果程序中对argv[]数组访问越界，会怎样？3、在c中该怎样确认scanf()输入了多少个字符？怎样确保安全性？怎样检查？
 

9、结构
首先要看一下C99对于结构体定义及使用的语法
定义
struct tag{
};
使用
struct tag a;    
即类型名之前一定要加上相应关键字，struct、enum、union都是如此！
当然C++下可以不用这么干，但在gcc下必须这么干。
如果对结构体使用typedef则可以不用写关键字，但使用typedef写链表时会出现各种神奇的东西，比如说就不可以使用ptr->next->next这样的东西。

13、文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。[1]
习惯上，标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。尽管这种习惯并非Unix内核的特性，但是因为一些 shell 和很多应用程序都使用这种习惯，因此，如果内核不遵循这种习惯的话，很多应用程序将不能使用。
POSIX 定义了 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO 来代替 0、1、2。这三个符号常量的定义位于头文件 <unistd.h>。

如果尝试运行自己的getchar()的话，需要在前面加个undef getchar,因为在头文件中是以宏定义的方式实现getchar的；

一般来说，使用系统调用比使用标准库函数中等价功能的函数执行速度要快。在使用系统调用时，有时加上了-std=c99选项反而编译出warning: implicit declaration of function，但能通过；放到-std=gnu99下面或者直接去掉-std=c99就没有warning；不知道为什么。在main函数前面加个extern声明就没有warning了。？？？？？？？？？？？？？？？？
 
14、 C Programming Language第八章8.6的实例
if ((stbuf.st_mode & S_IFMT) == S_IFDIR);
这其中的有好几个宏定义，&后面的是掩码，等于号后面的是判别码。而且Unix和Linux中stat结构的定义大同小异，这也就是为什么在fsize中用了系统调用，却仍然将其当做可移植部分。因为在不同的系统版本中，不同的目录格式和确切内容大不相同，因而那个才是不可移植的部分。将不可移植部分和可移植部分分开，使不可移植的代码量尽可能的少，可以提高代码的复用率。
Unix中每个目录中都包含了自身“.”和父目录“..”，因而在目录时要特别留意将它们排除掉，否则会有死循环。
两个函数之间可以相互调用，可以使用函数指针来实现，直接调用好像也没问题。


15、宏定义与typedef
宏定义与typedef在降低修改难度，提高程序可读性方面作用巨大。
（1） 宏定义的使用
```c
#define getc(p) (--(p)->cnt >= 0 \
? (unsigned char) *(p)->ptr++ : _fillbuf(p))
#define putc(x,p) (--(p)->cnt >= 0 \
? *(p)->ptr++ = (x) : _flushbuf((x),p))
```
诸如此类的宏写得很简洁，可以有效减少函数调用的消耗。
注意：inline是C++中为减少函数调用消耗而引入的一种解决方案，C中没有这个关键词。
将问题相关的数据表示为宏定义的形式，可以降低修改程序的难度，提高代码的可移植性，可重用性。
将某些不用改变的数据定义成宏可以便于阅读理解，请注意，软件开发中最大的成本是人力成本，减小维护成本是很重要的。
一个注意点：宏定义执行的只是编译预处理阶段的字符串替换，一定要认真考虑执行顺序，要避免一下这种情况的出现
在使用宏定义时记得多加几个括号，以防出现由于运算优先级的差别出现意想不到的情况
```c
#define mod(x,y) x%y
int a=c/mod(x,y);
```
又例如：


    #define labs(a) (a>0?a:-a)
如果这样使用了就永远也算不出正确的绝对值

    int e=labs(c-d);

因为其经过字符串替换后实际变成了
    
    int e=(a>0?a:-c-d)
但给a加上一个括号就没事了，所以记得多加几个括号！
（2）typedef的使用
typedef可以提高程序的可读性，更重要的是可以提高程序的可移植性。可用typedef定义机器无关的类型，便于移植。


16、在c中const定义的是只读变量（在定义时赋值，以后不可以更改），define定义的宏当做常量；而在C++ 中const表示的是常量。
而在C中定义数组时，数组长度必须是常量，因此只能是字面值或宏定义的数值。 #define length 100
const int length_const =100；
int array[length_const];                    //gcc编译报错error: variably modified ‘array_test’ at file scope
int array[length];                          //正确


18、jump to label “” crosses initialization of
问题原因：强行跳转跳过了变量的初始化。

19、C库函数的危险性
以scanf为例
```c
#include<stdio.h>
int main() 
{ 
	int b; 
	char string[10]; 
/*	for(int i=0;i<10;i++) 
	{ 
		printf("%d ",string[i]); 
	} 
	printf("\n"); 
*/ 
	string[0]=0; 
	string[1]=0; 
	scanf("%d %d",&string[0],&b); 
	/*for(int i=31;i>=0;i--) 
	{ 
		int temp=b; 
		temp=((temp>>31)==0)?0:1; 
		b=b<<1; 
		printf("%d ",temp); 
	} 
	printf("\n");*/ 
	for(int j=0;j<=1;j++) 
	{ 
		for(int i=7;i>=0;i--) 
		{ 
			int temp=string[j]; 
			temp=((temp>>7)==0)?0:1; 
			string[j]=(string[j]<<1); 
			printf("%d ",temp); 
		} 
		printf("		"); 
	} 
	printf("\n"); 
	char *p_0=&b; 
	char *p_1=p_0+1; 
	char *p_2=p_0+2; 
	char *p_3=p_0+3; 
	char a_1=*p_0; 
	char a_2=*p_1; 
	char a_3=*p_2; 
	char a_4=*p_3; 
	for(int i=7;i>=0;i--) 
	{ 
		int temp=a_1; 
		temp=((temp>>7)==0)?0:1; 
		a_1=((a_1)<<1); 
		printf("%d ",temp); 
	} 
	printf(" "); 
	for(int i=7;i>=0;i--) 
	{ 
		int temp=a_2; 
		temp=((temp>>7)==0)?0:1; 
		a_2=((a_2)<<1); 
		printf("%d ",temp); 
	} 
	printf(" "); 
	for(int i=7;i>=0;i--) 
	{ 
		int temp=a_3; 
		temp=((temp>>7)==0)?0:1; 
		a_3=((a_3)<<1); 
		printf("%d ",temp); 
	} 
	printf(" "); 
	for(int i=7;i>=0;i--) 
	{ 
		int temp=a_4; 
		temp=((temp>>7)==0)?0:1; 
		a_4=((a_4)<<1); 
		printf("%d ",temp); 
	} 
	printf(" "); 
	printf("\n"); 
	printf("%ld %ld %ld %ld\n",p_0,p_1,p_2,p_3); 
	int *test_1=&b; 
	int *test_2=test_1+1; 
	printf("%ld %ld ",test_1,test_2); 
	printf("%ld %ld",(*test_1),(*test_2)); 
	return 0; 
}
```
运行一下这段程序就会发现：
（1）当对string[0]赋一个较大的值时，会发生溢出，上溢的值写入了string[1]，产生了不合法的行为。
（2）将他们的每一位显示出来，可以发现高位写入了string[1]，剩余的低位写入了string[0]。再研究一下int类型的二进制存储方式，可以发现，内存地址的低位存储补码的低位，高位存储补码的高位。且编译器在进行存储位置安排的时候都已经自动地进行了地址的对齐。
（3）加减乘除的上下溢出、移位操作、以及赋一个极大的值时的溢出，根据C语言标准，予以截断，产生了一个未定义的值、出问题的只是相应的存储单元，危害性不是太大；但一些C语言库函数如scanf、字符串拷贝函数等，溢出会影响附近的存储单元，即存在破坏堆栈的危险，危害性较大！网络上似乎有相应的安全版本的库函数可供使用。

20、自增自减运算符的使用
自增自减运算符有副作用，使用自增自减运算符时一定要注意上下文对使用此变量的依赖性。

22、while循环与for循环
for循环语句：
for(表达式1；表达式2；表达式3)
	语句
等价于下列while语句：
表达式1;
while(表达式2)
{
	语句
	表达式3; }
注意在使用for循环时，表达式1只执行一次，表达式3才会执行很多次。
例如下面这个奇葩的程序：
  int main() 
  { 
          for(int c=getchar();c!=EOF;) 
                  printf("%d ",c); 
          return 0; 
  }       
是个死循环！！！！！！

23、输入输出
1、EOF：标准库中的EOF在实现时，基本是令EOF=-1，在实际stdin上输入时Ctrl+D可以输入EOF。注意：换行、制表、以及空格都算字符，都是可以用getchar()读取的。
返回值：输入输出库函数基本都有返回值用于判断操作是否成功，虽然我们基本都忽略这些返回值，但有些时候这些返回值作用很大。例如scanf()操作不成功时会返回EOF，那我们就可以直接利用scanf()判断输出的结束，而不必傻傻地使用getchar()。
当scanf扫描完其格式串或者碰到某些输入无法与格式控制说明匹配的情况时，该函数终止，同时成功匹配并赋值的项的个数作为将作为函数值返回。
2、ungetc()：可以利用ungetc()将已经从流中读出的内容再写到流中，可用于预读取一个字符判断完之后再写入流中，而不对流产生影响。例如ungetc(c,stdin);。
3、C语言标准输入输出库函数在实现时，是许多函数共用一块输入输出buffer，而且每个输入输出函数对于空格以及换行这些奇葩的字符处理方式大不相同，这就导致你如果对每个库函数读取buffer中字符的方式不太理解的话，相继使用几个库函数时，就会因为对buffer读取字符时空格换行的处理不同，导致出现意想不到的奇葩结果。
例如：
输入：helloworld\n
scanf("%s",str_1);
fgets(str_2,100,stdin);  //注意：由于scanf不读取buffer中的'\n'换行符，导致buffer非空，这样fgets会直接读取buffer，而不会等待输入，结果就使得fgets读取的不是想要的结果！
printf("%s\n%s\n******");
输出：
helloworld

******
这就是所谓的输入缓冲区脏数据！
最好使用这个原始的办法：
```
void ClearStdinBuf()
{
	char c;
	while((c=getchar())!='\n'&&c!=EOF)
		;
}
```
注意：这个只针对不读取换行符的函数如scanf()，在使用scanf()之后建议使用这个清空缓冲区，使用fgets()则不要使用，否则getchar()会一直等待输入！

4、fflush()
int fflush(FILE *stream);
对于输出流来说，fflush函数将已写到缓冲区但尚未写入文件的的所有数据写入到文件中。对于输入流来说，其结果是未定义的（对于vc6，其有fflush(stdin)的扩展，而gcc不支持这个，但编译时也不会报错）。如果在写的过程中发生错误，则返回EOF，否则返回0。fflush(NULL)将清洗所有的输出流（何为清洗？？？到底是写还是遗弃？？？）。
5、fgets，gets
fgets读取固定长度的字符，遇到换行符终止，将换行符读入但不做处理，并以'\0'结尾；
gets遇到换行符终止，换行符读入并替换为'\0'。

25、void类型是一种特殊的类型void可以指代任何类型，不仅可以是简单类型，甚至可以是指针类型、乃至二级三级指针，因为指针也算是一种类型。 例如
```
void func(char *********************p)
{
}
void *a;
func(a);
```
//此处不报错，也没有任何warning


28、C语言命令执行函数system()
system() executes a command specified in command by calling /bin/sh -c command,and returns after the command has been completed.During exection of the command,SIGCHLD will be blocked,and SIGINT and SIGQUIT will be ignored.

29、error：labs redeclared as different kind of symbol
有可能你根本没在源文件中发现某个变量的重定义，那么就要考虑是不是包含进的文件中定义了这个名字，不要忘记你的变量名也有可能一不小心和库函数中的文件名撞车！

30、千万不要在头文件中定义函数，否则如果有多个文件包含了它，则在编译的时候会出现函数的redefinition！如果要让调用者可以自己定义链接的函数的某些功能，可以采用函数指针的形式。

C语言字符串换行
可以将若干个""中间以空白、tab或者换行分隔开，编译器将自动将其处理为一个连续的字符串。这样可以提高代码的可读性。
例如：

```
 printf("sizeof(char):%d\nsizeof(short):%d\n"
              "sizeof(int):%d\nsizeof(long):%d\n"
              "sizeof(float):%d\nsizeof(double)%d\n"
              "sizeof(long long)%d\nsizeof(long double)%d\n",
              sizeof(char),sizeof(short),
              sizeof(int),sizeof(long),
              sizeof(float),sizeof(double),
              sizeof(long long),sizeof(long double));
```

除非是有特殊的封装需要，否则不要滥用pair，这样很容易降低程序的可读性。
每天整理注意点。
强制类型转换以及运算优先级的相关问题。
使用vim时代码要每写几十行就保存一遍。！！！！血的教训啊！！！
尤其是在写大作业时！！！！！！！！！！！！！！！！！！！！！！
浮点数中的字面值是作为double来处理的，除非你显示地加了后缀。
注意有符号与无符号数之间的隐式转换与相互比较。
例如：C风格数组的下标访问时可以有-1与-2的，即他们是按有符号数来算地址的
而对于vector是绝对不可以的，会造成段错误，因为vector下标类型是unsigned。
在调用库函数时，也要小心。

注意库函数memset，虽然它接受的是一个是把一片内存区域赋值为一个int，但我估计是按字节赋值的，所以int会被强转成char（我猜的），实际表现确实如此。
所以网上好多赋值那个magic number，例如0x3f3f3f3f都是如此，但实际上有用的只有0x3f这个低字节。

C语言中变量链接时的强弱属性，以及tentative definition的引入有可能都是为了兼容以前的C代码。现代的C代码书写对于变量最好要做到：
1. 如果是定义就一定要赋初值
2. 合理使用static限制链接属性
对于符号有定义属性，和链接属性，只要出现在函数外的都是external definition，变量默认是global linkage，使用static修饰的变量链接属性变为local。
类似的，什么是符号，什么会出现在符号表中？
只要出现在函数外的变量定义都是符号，另外还有static定义的变量，对这些符号的定义或引用都会出现在符号表中。
其中static变量不管定义在哪里都会出现在符号表中，为了加以区分，如果是块内部的static变量，变量名后面一般都会加上行号以示区分。
对全局符号的引用一般都会生成重定位表项是明显的符号引用表项，而对static的引用一般会直接生成一个重定位表项，没有符号名，直接就是一个关于某个节的偏移。
3. 变量声明统一使用extern
4. 链接时使用gcc等提供的no-common选项

注意区分哪些东西是语言标准定义的，哪些是标准未定义的。例如上面所说的符号表的处理，链接的处理，数据的内存布局都是由编译器自行决定的。而编译器的表现有可能因为版本以及环境的不同而大不相同。课上讲的并不总是一定对，编译器也并不总是会怎样干，这些是标准未指定的，一切以编译器为准的。例如，初始化的数据并不总是放在data节，如果初始化为0，编译器有时会字节把它挪到bss节。

知识的正确性总是有条件的，千万不能教条主义！

快不快，要靠benchmark，不要靠猜！


由于历史原因，IA-32架构中将内存的读权限和执行权限合并在一起使用一个bit来表示，这样就使得可以读的页面一定可执行。这就为缓冲区溢出攻击创造了条件。在进入x86-64后，由AMD引入了NXbit，即可以标示哪些是可以执行，哪些是不可以的，即读写以及执行权限终于分开了。下面这段利用缓冲区溢出攻击的代码，在IA-32和x86-64下的表现大不相同。
 

```C
#include<stdio.h>

const char exec[]={0xb8, 0x03,0x00,0x00,0x00,0xc3};
int (*f)()=(int(*)())exec;

int main()
{
	int a;
	a=f();
	printf("a=%d\n",a);
	return 0;
}
```
 
 在IA-32上，不管exec数组放在哪里，都能正确输出"a=3"。
 一般的，当exec为const时则在rodata节。
 否则放在data节，如果未初始化则在bss节。
 如果放在main函数中，则在栈上。

在x86-64下，当且仅当exec是const时，它才与代码属于一个段，才拥有可执行权限。

谨慎使用内联汇编
编译器会根据语义使用一些trick，做一些优化。但是，我怀疑编译器对语义的理解也仅限于高级语言。对于内联汇编，编译器只是按照要求汇编，并不会理解你的意图。例如在做无符号乘法溢出判断时，
```C
unsigned char CF;
int mul(unsigned a, unsigned b)
{
	unsigned c = a * b;
	asm volatile ("setb CF\n");
	return CF;
}

```
这样子似乎是可以的，因为对于无符号乘法，应该使用mul，而mul如果产生了溢出，则按照手册，CF应该被置1。
但这是错误的，因为最终编译器为这个乘法生成了imul指令。这个trick是合理合法的，因为编译器只要保证语义正确，不管选用什么指令都是可以的。同时，这也告诉我们不要思维定式，无符号乘法并不一定选用mul指令。要弄清哪些是由标准指定的，无论何时都成立的；哪些是实现相关的。
查阅手册，可以发现，对于imul，只要最终结果可以放进一个32位寄存器里，则CF清零。这就导致当a和b为负数时，我们的判断程序是错误的。
为防止编译器的trick，使用内联汇编时，最好自己处理汇编的上下文。谨慎使用编译器为你生成的上下文。
正确的写法如下
```C
unsigned char CF;
int mul(unsigned a, unsigned b)
{
	asm volatile (
			"movl 0x8(%ebp), %eax\n"
			"movl 0xc(%ebp), %ecx\n"
			"mul  %ecx\n"
			"setb CF\n");
	return CF;
}

```

